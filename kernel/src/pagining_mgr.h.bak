#include <stdint.h>
#include <stddef.h>
#include "text_renderer.h"

#define PML4_SHIFT 39
#define PDP_SHIFT 30
#define PD_SHIFT 21
#define PT_SHIFT 12

#define PML4_INDEX(vaddr) (((vaddr) >> PML4_SHIFT) & 0x1FF)
#define PDP_INDEX(vaddr)  (((vaddr) >> PDP_SHIFT) & 0x1FF)
#define PD_INDEX(vaddr)   (((vaddr) >> PD_SHIFT) & 0x1FF)
#define PT_INDEX(vaddr)   (((vaddr) >> PT_SHIFT) & 0x1FF)

#define PAGE_PRESENT  (1 << 0)
#define PAGE_RW       (1 << 1)
#define PAGE_USER     (1 << 2)

static inline uint64_t read_cr3() {
    uint64_t cr3;
    asm volatile ("mov %%cr3, %0" : "=r"(cr3));
    return cr3;
}

// Assuming identity mapping or a known KERNEL_BASE
#define KERNEL_VIRTUAL_BASE 0xFFFF800000000000


// HHDM (Higher Half Direct Mapping) information

__attribute__((used, section(".limine_requests")))
static volatile struct limine_hhdm_request hhdm_request = {
    .id = LIMINE_HHDM_REQUEST,
    .revision = 0,    
};



void inspect_page_tables() {
    uint64_t cr3 = read_cr3();
    uint64_t* pml4 = (uint64_t*)(cr3 & ~0xFFF);
    
    // Get HHDM offset from Limine
    uint64_t hhdm_offset = hhdm_request.response->offset;
    kprintf("HHDM offset: 0x%lx\n", hhdm_offset);
    pml4 = (uint64_t*)(hhdm_offset + (uint64_t)pml4); // Convert to virtual
    
    for (int i = 0; i < 512; i++) {
        if (pml4[i] & 1) { // Present bit
            kprintf("PML4[%d] = 0x%lx\n", i, pml4[i]);
            
            // Get PDPT (Level 3)
            uint64_t* pdpt = (uint64_t*)((pml4[i] & ~0xFFF) + hhdm_offset);
            
            for (int j = 0; j < 512; j++) {
                if (pdpt[j] & 1) { // Present bit
                    kprintf("  PDPT[%d] = 0x%lx\n", j, pdpt[j]);
                    
                    // Check for 1GB page (PDPT PS bit)
                    if (pdpt[j] & (1 << 7)) { // <--- Explicit 1GB check
                        kprintf("    [1GB PAGE] Virtual: 0x%lx\n", 
                               ((uint64_t)i << 39) | ((uint64_t)j << 30));
                        continue; // Skip deeper traversal
                    }
                    
                    continue;
                    // Get PD (Level 2)
                    uint64_t* pd = (uint64_t*)((pdpt[j] & ~0xFFF) + hhdm_offset);
                    
                    // Check PD entries for 2MB pages
                    for (int k = 0; k < 512; k++) { // <--- Added PD traversal
                        if (pd[k] & 1) {
                            // Check for 2MB page (PD PS bit)
                            if (pd[k] & (1 << 7)) { // <--- Explicit 2MB check
                                kprintf("    [2MB PAGE] Virtual: 0x%lx\n", 
                                       ((uint64_t)i << 39) | ((uint64_t)j << 30) | ((uint64_t)k << 21));
                            }
                        }
                    }
                }
            }
        }
    }
}